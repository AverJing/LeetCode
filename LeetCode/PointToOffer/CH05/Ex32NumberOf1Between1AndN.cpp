/*
*
*
*@author: Aver Jing
*@description：
*@date：
*
*
*/

#include <iostream>

/*
链接：https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6
来源：牛客网

通过使用一个 位置乘子m 遍历数字的位置, m 分别为1,10,100,1000…etc.（m<=n）

对于每个位置来说，把10进制数分成两个部分，比如说 当m=100的时候， 
把十进制数 n=3141592 分成 a=31415 和 b=92 ，以此来分析百位数为1时所有数的个数和。
m=100时，百位数的前缀为3141，当百位数大于1时，为3142*100，
因为当百位数大于1时，前缀可以为0，即百位数可以从100到199，共100个数；
当百位数不大于1时，为3141*100；如何判断百位数是否大于1？
假设百位数为x，若（x+8）/10等于1，则大于1，若（x+8）/10等于0，则小于1。
因此前缀可用（n/m + 8）/10 *m来计算(若计算2的个数，可以改为（n/m + 7）/10*m,
若计算3的个数，改为（n/m + 6）/10*m，…以此类推)。

再例如m=1000时，n分为a=3141和 b=592；千位数的前缀为314，千位数不大于1，
故前缀计算为314*1000；因为千位数为1，再加b+1(0到592)。
即千位数为1的所有书的个数和为314*1000+592+1；公式（n/m + 8）/10*m + b +1。

注意：只有n的第m位为1时需要计算后缀，后缀计算为 （n/m%10==1）*(b+1)，

即（n/m%10==1）判断第m位是否为1，若为1，则加上（b+1），若不为1，则只计算前缀。
（若计算2的个数，可以改为（n/m%10==2）*(b+1)，若计算3的个数，
可以改为（n/m%10==3）*(b+1)…以此类推）
*/

 int NumberOf1Between1AndN_Solution(int n)
{
	int cnt = 0;
	int a = 0, b = 0;
	for (long long m = 1; m <= n; m *= 10) {
		 a = n / m;
		 b = n % m;
		 cnt += (a + 8) / 10 * m + (a % 10 == 1)*(b + 1);
	}
	return cnt;
}

int main(){
	
}	