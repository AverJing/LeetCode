难度符号说明（仅代表个人）：

 - ？多次思考可以尝试解决

思路：

- 和31题类似，31只求一个排列，此题求全排列
- 算法解释：
  - 先将序列从小到大排序，为nums
  - start和last是相邻的顺序列（\*start<\*last）,riter从后向前找到第一个比\*start大的值（确保该排列紧挨着上次的排列结果），交换start和riter，在逆序last到末尾
  - 注意退出条件，若start==nums.begin()，即有回到了nums。排列求完了